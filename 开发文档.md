# 渲染预热防火墙产品开发文档

## 1. 开发环境搭建

### 1.1 系统要求

| 组件                | 最低要求                | 推荐配置                |
|---------------------|-------------------------|-------------------------|
| 操作系统            | Linux/macOS             | Linux CentOS 7+/Ubuntu 18.04+ |
| CPU                 | 4核                     | 8核或更高               |
| 内存                | 8GB                     | 16GB或更高              |
| 磁盘                | 100GB                   | 200GB SSD               |
| 网络                | 1Gbps                   | 10Gbps                  |

### 1.2 开发工具安装

#### 1.2.1 Go环境安装

```bash
# 下载Go安装包
tar -C /usr/local -xzf go1.20.0.linux-amd64.tar.gz

# 设置环境变量
export PATH=$PATH:/usr/local/go/bin
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin

# 验证安装
go version
```

#### 1.2.2 Node.js环境安装

```bash
# 使用nvm安装Node.js
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
nvm install 18
nvm use 18

# 验证安装
node --version
npm --version
```

#### 1.2.3 Docker安装

```bash
# 安装Docker
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io

# 启动Docker服务
sudo systemctl start docker
sudo systemctl enable docker

# 验证安装
docker --version
```

#### 1.2.4 Kubernetes安装（可选，用于集群开发）

```bash
# 使用minikube安装Kubernetes（开发环境）
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# 启动minikube
minikube start

# 验证安装
kubectl version
```

### 1.3 开发依赖安装

#### 1.3.1 Go依赖管理

```bash
# 在项目根目录执行
go mod tidy
go mod download
```

#### 1.3.2 Node.js依赖管理

```bash
# 进入前端项目目录
cd web
npm install
```

#### 1.3.3 SSL证书生成（开发环境）

```bash
# 生成自签名SSL证书
mkdir -p certs
openssl req -x509 -newkey rsa:4096 -keyout certs/key.pem -out certs/cert.pem -days 365 -nodes
```

## 2. 项目结构

```
├── cmd/                      # 命令行入口
│   ├── api/                  # API服务入口
│   ├── gateway/              # 接入网关入口
│   ├── firewall/             # 防火墙服务入口
│   ├── prerender/            # 渲染预热服务入口
│   └── manager/              # 管理服务入口
├── internal/                 # 内部包
│   ├── config/               # 配置管理
│   ├── firewall/             # 防火墙核心逻辑
│   ├── prerender/            # 渲染预热核心逻辑
│   │   └── preheat/          # 缓存预热逻辑
│   ├── routing/              # 智能流量路由
│   ├── ssl/                  # SSL/TLS处理逻辑
│   │   ├── acme/             # ACME客户端实现
│   │   ├── cert/              # 证书管理
│   │   └── tls/              # TLS处理器
│   ├── cache/                # 缓存管理
│   ├── storage/              # 存储管理
│   ├── monitoring/           # 监控管理
│   └── utils/                # 工具函数
├── pkg/                      # 公共包
│   ├── logger/               # 日志库
│   ├── metrics/              # 指标库
│   ├── security/             # 安全工具
│   └── http/                 # HTTP工具
├── web/                      # 前端管理界面
│   ├── src/                  # 前端源代码
│   │   ├── components/       # 公共组件
│   │   │   ├── charts/       # 图表组件
│   │   │   ├── layouts/      # 布局组件
│   │   │   └── ui/           # 基础UI组件
│   │   ├── pages/            # 页面组件
│   │   │   ├── Overview/     # 概览页面
│   │   │   ├── Firewall/     # 防火墙配置页面
│   │   │   ├── Prerender/    # 渲染预热配置页面
│   │   │   ├── SSL/          # SSL管理页面
│   │   │   ├── Monitoring/   # 监控告警页面
│   │   │   ├── Logs/         # 日志管理页面
│   │   │   └── Settings/     # 系统设置页面
│   │   ├── services/         # API服务
│   │   ├── store/            # 状态管理
│   │   ├── utils/            # 工具函数
│   │   ├── styles/           # 全局样式
│   │   ├── types/            # TypeScript类型定义
│   │   ├── App.tsx           # 应用入口组件
│   │   └── main.tsx          # 应用入口文件
│   ├── public/               # 静态资源
│   ├── package.json          # 前端依赖
│   ├── vite.config.ts        # Vite配置
│   └── tsconfig.json         # TypeScript配置
├── configs/                  # 配置文件模板
├── deploy/                   # 部署脚本
│   ├── docker/               # Docker相关配置
│   ├── k8s/                  # Kubernetes相关配置
│   └── scripts/              # 部署脚本
├── tests/                    # 测试目录
│   ├── unit/                 # 单元测试
│   ├── integration/          # 集成测试
│   └── e2e/                  # 端到端测试
├── docs/                     # 文档目录
├── go.mod                    # Go模块定义
├── go.sum                    # Go依赖校验
├── Makefile                  # 构建脚本
└── README.md                 # 项目说明
```

## 3. 核心模块技术实现

### 3.1 智能流量路由模块

#### 3.1.1 实现思路
- 采用中间件模式，在请求处理流程中插入路由逻辑
- 实现基于规则的匹配引擎，支持多维度特征匹配
- 使用决策树算法优化路由决策过程
- 支持动态规则加载和更新

#### 3.1.2 核心代码结构

```go
// internal/routing/router.go
package routing

import (
    "net/http"
    "sync"
)

type Router struct {
    rules     []*RouteRule
    mutex     sync.RWMutex
    matcher   Matcher
    cache     Cache
}

func NewRouter(config Config) *Router {
    // 初始化路由规则
    // 初始化匹配器
    // 初始化缓存
    return &Router{}
}

func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    // 解析请求
    // 匹配路由规则
    // 执行路由操作
    // 调用下一个中间件或处理函数
}

func (r *Router) UpdateRules(rules []*RouteRule) error {
    // 更新路由规则
    // 重新加载匹配器
    return nil
}
```

### 3.2 防火墙引擎模块

#### 3.2.1 实现思路
- 专注于OWASP Top 10威胁防护
- 采用规则和机器学习相结合的检测方式
- 实现基于AC自动机的多模式匹配，提高规则匹配效率
- 支持实时规则更新和威胁情报同步
- 提供详细的攻击分析和报告

#### 3.2.2 核心代码结构

```go
// internal/firewall/engine.go
package firewall

import (
    "net/http"
    "sync"
    "prerender/internal/firewall/detectors"
    "prerender/internal/firewall/actions"
    "prerender/internal/firewall/rules"
)

type Engine struct {
    mutex                 sync.RWMutex
    owaspDetectors        map[string]detectors.OWASPDetector
    coreDetectors         []detectors.CoreDetector
    actionHandler         actions.Handler
    ruleManager           *rules.Manager
    logger                Logger
}

type Config struct {
    OWASPRulesPath        string
    CoreRulesPath        string
    ActionConfig         actions.Config
    LoggerConfig         LoggerConfig
}

func NewEngine(config Config) (*Engine, error) {
    // 初始化规则管理器
    ruleMgr, err := rules.NewManager(config.OWASPRulesPath, config.CoreRulesPath)
    if err != nil {
        return nil, err
    }
    
    // 初始化动作处理器
    actionHandler, err := actions.NewHandler(config.ActionConfig)
    if err != nil {
        return nil, err
    }
    
    // 初始化日志器
    logger, err := NewLogger(config.LoggerConfig)
    if err != nil {
        return nil, err
    }
    
    // 初始化OWASP Top 10检测器
    owaspDetectors := make(map[string]detectors.OWASPDetector)
    
    // 注入攻击检测器
    owaspDetectors["injection"] = detectors.NewInjectionDetector(ruleMgr)
    
    // XSS攻击检测器
    owaspDetectors["xss"] = detectors.NewXSSDetector(ruleMgr)
    
    // CSRF攻击检测器
    owaspDetectors["csrf"] = detectors.NewCSRFDetector(ruleMgr)
    
    // 不安全的反序列化检测器
    owaspDetectors["deserialization"] = detectors.NewDeserializationDetector(ruleMgr)
    
    // 敏感数据泄露检测器
    owaspDetectors["sensitive-data"] = detectors.NewSensitiveDataDetector(ruleMgr)
    
    // 初始化核心检测器
    coreDetectors := []detectors.CoreDetector{
        detectors.NewAPISecurityDetector(ruleMgr),
        detectors.NewRateLimitDetector(ruleMgr),
        detectors.NewAnomalyDetector(ruleMgr),
        detectors.NewMaliciousRequestDetector(ruleMgr),
    }
    
    return &Engine{
        owaspDetectors:    owaspDetectors,
        coreDetectors:     coreDetectors,
        actionHandler:     actionHandler,
        ruleManager:       ruleMgr,
        logger:            logger,
    }, nil
}

func (e *Engine) CheckRequest(req *http.Request) (*CheckResult, error) {
    result := &CheckResult{
        Threats: make([]Threat, 0),
    }
    
    // 执行OWASP Top 10检测
    for name, detector := range e.owaspDetectors {
        threats, err := detector.Detect(req)
        if err != nil {
            e.logger.Error("Detector error: %s", err.Error())
            continue
        }
        result.Threats = append(result.Threats, threats...)
    }
    
    // 执行核心安全检测
    for _, detector := range e.coreDetectors {
        threats, err := detector.Detect(req)
        if err != nil {
            e.logger.Error("Core detector error: %s", err.Error())
            continue
        }
        result.Threats = append(result.Threats, threats...)
    }
    
    return result, nil
}

func (e *Engine) HandleRequest(w http.ResponseWriter, req *http.Request) bool {
    // 检查请求
    result, err := e.CheckRequest(req)
    if err != nil {
        e.logger.Error("Check request error: %s", err.Error())
        return true // 出错时默认允许请求通过
    }
    
    // 如果检测到威胁，执行相应动作
    if len(result.Threats) > 0 {
        // 记录安全事件
        e.logger.LogSecurityEvent(req, result)
        
        // 执行动作
        return e.actionHandler.Handle(w, req, result)
    }
    
    return true // 允许请求通过
}

func (e *Engine) UpdateRules() error {
    // 更新规则
    return e.ruleManager.ReloadRules()
}
```

#### 3.2.3 OWASP Top 10检测器接口

```go
// internal/firewall/detectors/owasp.go
package detectors

import (
    "net/http"
    "prerender/internal/firewall/types"
)

type OWASPDetector interface {
    Detect(req *http.Request) ([]types.Threat, error)
    Name() string
}

// 注入攻击检测器实现
// internal/firewall/detectors/injection.go
package detectors

import (
    "net/http"
    "prerender/internal/firewall/rules"
    "prerender/internal/firewall/types"
)

type InjectionDetector struct {
    ruleManager *rules.Manager
}

func NewInjectionDetector(ruleManager *rules.Manager) *InjectionDetector {
    return &InjectionDetector{
        ruleManager: ruleManager,
    }
}

func (d *InjectionDetector) Detect(req *http.Request) ([]types.Threat, error) {
    threats := make([]types.Threat, 0)
    
    // 获取注入攻击规则
    injectionRules := d.ruleManager.GetRulesByCategory("injection")
    
    // 检查请求参数
    for name, values := range req.URL.Query() {
        for _, value := range values {
            for _, rule := range injectionRules {
                if rule.Match(value) {
                    threats = append(threats, types.Threat{
                        Type:       "injection",
                        SubType:    "sql_injection",
                        Severity:   "high",
                        Message:    "SQL injection detected",
                        Parameter:  name,
                        Value:      value,
                        RuleID:     rule.ID,
                        RuleName:   rule.Name,
                    })
                }
            }
        }
    }
    
    // 检查请求体
    if req.Method == "POST" || req.Method == "PUT" {
        // 解析请求体并检查
        // ...
    }
    
    return threats, nil
}

func (d *InjectionDetector) Name() string {
    return "injection_detector"
}
```

#### 3.2.4 核心安全检测器接口

```go
// internal/firewall/detectors/core.go
package detectors

import (
    "net/http"
    "prerender/internal/firewall/types"
)

type CoreDetector interface {
    Detect(req *http.Request) ([]types.Threat, error)
    Name() string
}

// API安全检测器实现
// internal/firewall/detectors/api_security.go
package detectors

import (
    "net/http"
    "prerender/internal/firewall/rules"
    "prerender/internal/firewall/types"
)

type APISecurityDetector struct {
    ruleManager *rules.Manager
}

func NewAPISecurityDetector(ruleManager *rules.Manager) *APISecurityDetector {
    return &APISecurityDetector{
        ruleManager: ruleManager,
    }
}

func (d *APISecurityDetector) Detect(req *http.Request) ([]types.Threat, error) {
    threats := make([]types.Threat, 0)
    
    // API请求验证
    apiRules := d.ruleManager.GetRulesByCategory("api_security")
    
    // 检查API签名
    // 检查请求头完整性
    // 检查参数格式
    // ...
    
    return threats, nil
}

func (d *APISecurityDetector) Name() string {
    return "api_security_detector"
}
```

### 3.3 渲染预热引擎模块

#### 3.3.1 实现思路
- 基于Headless Chrome/Chromium，使用Puppeteer进行页面渲染
- 实现渲染任务队列，支持并发渲染
- 实现渲染结果缓存，提高响应速度
- 支持自定义渲染规则和超时控制
- 支持Sitemap解析和大规模缓存预热

#### 3.3.2 核心代码结构

```javascript
// internal/prerender/engine.js
const puppeteer = require('puppeteer');
const { EventEmitter } = require('events');
const PreheatManager = require('./preheat/manager');

class PrerenderEngine extends EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.browserPool = [];
        this.taskQueue = [];
        this.isRunning = false;
        // 初始化浏览器池
        this.initBrowserPool();
        // 初始化预热管理器
        this.preheatManager = new PreheatManager(config.preheat, this);
    }

    async initBrowserPool() {
        // 创建浏览器实例池
        for (let i = 0; i < this.config.poolSize; i++) {
            const browser = await puppeteer.launch({
                headless: true,
                args: ['--no-sandbox', '--disable-setuid-sandbox']
            });
            this.browserPool.push(browser);
        }
    }

    async render(url, options) {
        // 执行页面渲染
        // 返回渲染结果
        const browser = this.getBrowserFromPool();
        const page = await browser.newPage();
        
        try {
            await page.goto(url, {
                waitUntil: 'networkidle0',
                timeout: options.timeout || 30000
            });
            
            const html = await page.content();
            return { html, success: true };
        } catch (error) {
            return { error: error.message, success: false };
        } finally {
            await page.close();
            this.returnBrowserToPool(browser);
        }
    }

    getBrowserFromPool() {
        // 从浏览器池获取浏览器实例
        return this.browserPool.shift();
    }

    returnBrowserToPool(browser) {
        // 将浏览器实例返回浏览器池
        this.browserPool.push(browser);
    }

    async close() {
        // 关闭所有浏览器实例
        for (const browser of this.browserPool) {
            await browser.close();
        }
        // 关闭预热管理器
        await this.preheatManager.close();
    }
}

module.exports = PrerenderEngine;
```

#### 3.3.3 缓存预热模块实现

```javascript
// internal/prerender/preheat/manager.js
const { EventEmitter } = require('events');
const axios = require('axios');
const { parseStringPromise } = require('xml2js');
const cron = require('node-cron');

class PreheatManager extends EventEmitter {
    constructor(config, engine) {
        super();
        this.config = config;
        this.engine = engine;
        this.tasks = new Map();
        this.running = false;
        // 初始化定时任务
        this.initCron();
    }

    initCron() {
        if (this.config.schedule) {
            cron.schedule(this.config.schedule, () => {
                this.triggerPreheat();
            });
        }
    }

    async triggerPreheat() {
        if (this.running) {
            return;
        }

        this.running = true;
        try {
            // 解析Sitemap
            const urls = await this.parseSitemap(this.config.sitemapUrl);
            
            // 生成预热任务
            const tasks = urls.map(url => ({
                id: `preheat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                url,
                priority: this.config.defaultPriority || 0,
                status: 'pending',
                createdAt: new Date()
            }));

            // 保存任务
            tasks.forEach(task => this.tasks.set(task.id, task));
            
            // 批量执行预热
            await this.executePreheat(tasks);
            
            this.emit('preheatComplete', { total: tasks.length, success: this.getSuccessCount(), failed: this.getFailedCount() });
        } catch (error) {
            this.emit('preheatError', error);
        } finally {
            this.running = false;
        }
    }

    async parseSitemap(url) {
        try {
            const response = await axios.get(url);
            const xml = response.data;
            const result = await parseStringPromise(xml);
            
            // 解析Sitemap获取URL列表
            const urls = [];
            if (result.urlset && result.urlset.url) {
                result.urlset.url.forEach(item => {
                    if (item.loc && item.loc[0]) {
                        urls.push(item.loc[0]);
                    }
                });
            }
            
            return urls;
        } catch (error) {
            throw new Error(`Failed to parse sitemap: ${error.message}`);
        }
    }

    async executePreheat(tasks) {
        // 并发控制
        const concurrency = this.config.concurrency || 5;
        const batches = [];
        
        // 将任务分成多个批次
        for (let i = 0; i < tasks.length; i += concurrency) {
            batches.push(tasks.slice(i, i + concurrency));
        }
        
        // 逐批次执行
        for (const batch of batches) {
            // 并行执行当前批次的任务
            await Promise.all(batch.map(task => this.preheatTask(task)));
        }
    }

    async preheatTask(task) {
        try {
            task.status = 'running';
            task.startedAt = new Date();
            this.updateTask(task);
            
            // 执行渲染
            const result = await this.engine.render(task.url, {
                timeout: this.config.timeout || 30000
            });
            
            if (result.success) {
                task.status = 'completed';
                task.completedAt = new Date();
            } else {
                task.status = 'failed';
                task.error = result.error;
                task.completedAt = new Date();
            }
        } catch (error) {
            task.status = 'failed';
            task.error = error.message;
            task.completedAt = new Date();
        } finally {
            this.updateTask(task);
        }
    }

    updateTask(task) {
        this.tasks.set(task.id, task);
        this.emit('taskUpdate', task);
    }

    getTask(id) {
        return this.tasks.get(id);
    }

    getAllTasks() {
        return Array.from(this.tasks.values());
    }

    getSuccessCount() {
        return Array.from(this.tasks.values()).filter(task => task.status === 'completed').length;
    }

    getFailedCount() {
        return Array.from(this.tasks.values()).filter(task => task.status === 'failed').length;
    }

    async close() {
        // 清理资源
    }
}

module.exports = PreheatManager;
```

#### 3.3.4 预热API实现

```go
// internal/api/preheat.go
package api

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "prerender/internal/prerender/preheat"
)

type PreheatHandler struct {
    manager *preheat.Manager
}

func NewPreheatHandler(manager *preheat.Manager) *PreheatHandler {
    return &PreheatHandler{
        manager: manager,
    }
}

func (h *PreheatHandler) RegisterRoutes(router *gin.Engine) {
    preheatGroup := router.Group("/api/v1/prerender/preheat")
    {
        preheatGroup.GET("/tasks", h.ListTasks)
        preheatGroup.POST("/trigger", h.TriggerPreheat)
        preheatGroup.GET("/status", h.GetStatus)
    }
}

func (h *PreheatHandler) ListTasks(c *gin.Context) {
    tasks := h.manager.GetAllTasks()
    c.JSON(http.StatusOK, gin.H{
        "code": 200,
        "message": "success",
        "data": tasks,
    })
}

func (h *PreheatHandler) TriggerPreheat(c *gin.Context) {
    go h.manager.TriggerPreheat()
    c.JSON(http.StatusOK, gin.H{
        "code": 200,
        "message": "Preheat triggered successfully",
    })
}

func (h *PreheatHandler) GetStatus(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        "code": 200,
        "message": "success",
        "data": {
            "running": h.manager.IsRunning(),
            "totalTasks": len(h.manager.GetAllTasks()),
            "successCount": h.manager.GetSuccessCount(),
            "failedCount": h.manager.GetFailedCount(),
        },
    })
}
```

### 3.4 配置中心模块

#### 3.4.1 实现思路
- 基于etcd实现分布式配置存储
- 支持配置版本管理和历史记录
- 实现配置变更通知机制
- 支持配置验证和自动回滚

#### 3.4.2 核心代码结构

```go
// internal/config/center.go
package config

import (
    "context"
    "time"
    "go.etcd.io/etcd/client/v3"
)

type Center struct {
    client     *clientv3.Client
    watcher    clientv3.Watcher
    callbacks  []Callback
    mutex      sync.RWMutex
}

type Callback func(key string, value []byte) error

func NewCenter(config Config) (*Center, error) {
    // 创建etcd客户端
    // 初始化配置中心
    client, err := clientv3.New(clientv3.Config{
        Endpoints:   config.Endpoints,
        DialTimeout: 5 * time.Second,
    })
    if err != nil {
        return nil, err
    }
    
    return &Center{
        client: client,
        watcher: clientv3.NewWatcher(client),
    }, nil
}

func (c *Center) Get(key string) (string, error) {
    // 获取配置
    resp, err := c.client.Get(context.Background(), key)
    if err != nil {
        return "", err
    }
    
    if len(resp.Kvs) > 0 {
        return string(resp.Kvs[0].Value), nil
    }
    
    return "", nil
}

func (c *Center) Put(key, value string) error {
    // 设置配置
    _, err := c.client.Put(context.Background(), key, value)
    return err
}

func (c *Center) Watch(key string, callback Callback) error {
    // 监听配置变更
    // 注册回调函数
    go func() {
        watchChan := c.watcher.Watch(context.Background(), key, clientv3.WithPrefix())
        for resp := range watchChan {
            for _, ev := range resp.Events {
                callback(string(ev.Kv.Key), ev.Kv.Value)
            }
        }
    }()
    
    return nil
}

func (c *Center) Close() error {
    // 关闭配置中心
    return c.client.Close()
}
```

### 3.5 SSL/TLS 处理模块

#### 3.5.1 实现思路
- 实现证书管理和自动续期
- 支持多种证书获取方式（自定义证书、Let's Encrypt）
- 实现高性能的TLS握手处理
- 支持SNI和多域名证书

#### 3.5.2 核心代码结构

```go
// internal/ssl/cert/manager.go
package cert

import (
    "crypto/tls"
    "time"
)

type Manager struct {
    certs    map[string]*tls.Certificate
    mutex    sync.RWMutex
    acme     *ACMEManager
    config   *Config
}

type Config struct {
    Enabled          bool
    LetEncrypt       bool
    Domains          []string
    ACMEEmail        string
    ACMEServer       string
    ACMEChallenge    string
    CertPath         string
    KeyPath          string
}

func NewManager(config *Config) (*Manager, error) {
    m := &Manager{
        certs:  make(map[string]*tls.Certificate),
        config: config,
    }
    
    // 初始化ACME管理器
    if config.LetEncrypt {
        acme, err := NewACMEManager(config)
        if err != nil {
            return nil, err
        }
        m.acme = acme
    }
    
    // 加载初始证书
    if err := m.loadCertificates(); err != nil {
        return nil, err
    }
    
    return m, nil
}

func (m *Manager) GetCertificate(h *tls.ClientHelloInfo) (*tls.Certificate, error) {
    // 根据SNI获取证书
    m.mutex.RLock()
    cert, ok := m.certs[h.ServerName]
    m.mutex.RUnlock()
    
    if ok {
        return cert, nil
    }
    
    // 尝试获取默认证书
    m.mutex.RLock()
    cert, ok = m.certs["default"]
    m.mutex.RUnlock()
    
    if ok {
        return cert, nil
    }
    
    // 如果启用了LetEncrypt，尝试自动申请证书
    if m.acme != nil {
        if err := m.acme.IssueCertificate(h.ServerName); err == nil {
            // 重新加载证书
            if err := m.loadCertificates(); err == nil {
                m.mutex.RLock()
                cert, ok = m.certs[h.ServerName]
                m.mutex.RUnlock()
                if ok {
                    return cert, nil
                }
            }
        }
    }
    
    return nil, tls.CertificateRequestError{}
}

func (m *Manager) loadCertificates() error {
    // 加载证书逻辑
    // ...
    return nil
}

func (m *Manager) Start() {
    // 启动证书更新定时器
    go func() {
        ticker := time.NewTicker(24 * time.Hour)
        defer ticker.Stop()
        
        for range ticker.C {
            if m.acme != nil {
                m.acme.RenewCertificates()
                m.loadCertificates()
            }
        }
    }()
}
```

#### 3.5.3 ACME客户端实现

```go
// internal/ssl/acme/client.go
package acme

import (
    "crypto"
    "crypto/ecdsa"
    "crypto/elliptic"
    "crypto/rand"
    "github.com/go-acme/lego/v4/certcrypto"
    "github.com/go-acme/lego/v4/certificate"
    "github.com/go-acme/lego/v4/challenge/http01"
    "github.com/go-acme/lego/v4/lego"
    "github.com/go-acme/lego/v4/registration"
)

type ACMEManager struct {
    client     *lego.Client
    config     *Config
    user       *User
}

type Config struct {
    Email       string
    ServerURL   string
    Challenge   string
    Domains     []string
}

type User struct {
    Email        string
    Registration *registration.Resource
    Key          crypto.PrivateKey
}

func NewACMEManager(config *Config) (*ACMEManager, error) {
    // 生成用户密钥
    privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
    if err != nil {
        return nil, err
    }
    
    user := &User{
        Email: config.Email,
        Key:   privateKey,
    }
    
    // 创建ACME客户端配置
    cfg := lego.NewConfig(user)
    cfg.CADirURL = config.ServerURL
    cfg.Certificate.KeyType = certcrypto.RSA2048
    
    // 创建ACME客户端
    client, err := lego.NewClient(cfg)
    if err != nil {
        return nil, err
    }
    
    // 配置HTTP-01挑战
    if err := client.Challenge.SetHTTP01Provider(http01.NewProviderServer("", "80")); err != nil {
        return nil, err
    }
    
    // 注册用户
    reg, err := client.Registration.Register(registration.RegisterOptions{
        TermsOfServiceAgreed: true,
    })
    if err != nil {
        return nil, err
    }
    user.Registration = reg
    
    return &ACMEManager{
        client: client,
        config: config,
        user:   user,
    }, nil
}

func (m *ACMEManager) IssueCertificate(domain string) error {
    // 申请证书
    request := certificate.ObtainRequest{
        Domains: []string{domain},
        Bundle:  true,
    }
    
    _, err := m.client.Certificate.Obtain(request)
    return err
}

func (m *ACMEManager) RenewCertificates() {
    // 续期所有证书
    // ...
}
```

#### 3.5.4 TLS服务器配置

```go
// internal/ssl/tls/server.go
package tls

import (
    "crypto/tls"
    "net/http"
    "prerender/internal/ssl/cert"
)

type Server struct {
    httpServer *http.Server
    certMgr    *cert.Manager
    config     *Config
}

type Config struct {
    Address      string
    CertConfig   *cert.Config
    Handler      http.Handler
    TLSConfig    *tls.Config
}

func NewServer(config *Config) (*Server, error) {
    // 创建证书管理器
    certMgr, err := cert.NewManager(config.CertConfig)
    if err != nil {
        return nil, err
    }
    
    // 创建TLS配置
    tlsConfig := &tls.Config{
        GetCertificate: certMgr.GetCertificate,
        MinVersion:     tls.VersionTLS12,
        CipherSuites:   []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
            tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
            tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
        },
    }
    
    // 合并用户自定义TLS配置
    if config.TLSConfig != nil {
        if config.TLSConfig.MinVersion != 0 {
            tlsConfig.MinVersion = config.TLSConfig.MinVersion
        }
        if len(config.TLSConfig.CipherSuites) > 0 {
            tlsConfig.CipherSuites = config.TLSConfig.CipherSuites
        }
    }
    
    httpServer := &http.Server{
        Addr:      config.Address,
        Handler:   config.Handler,
        TLSConfig: tlsConfig,
    }
    
    return &Server{
        httpServer: httpServer,
        certMgr:    certMgr,
        config:     config,
    }, nil
}

func (s *Server) Start() error {
    // 启动证书管理器
    s.certMgr.Start()
    
    // 启动HTTP服务器
    return s.httpServer.ListenAndServeTLS("", "")
}

func (s *Server) Shutdown(ctx context.Context) error {
    return s.httpServer.Shutdown(ctx)
}
```

### 3.6 管理界面技术实现

#### 3.6.1 前端技术栈详细说明

| 技术/库                | 版本     | 用途                                   |
|-----------------------|----------|----------------------------------------|
| React                 | 18.2.0   | 前端框架                               |
| TypeScript            | 5.2.0    | 类型安全                               |
| Ant Design            | 5.8.0    | UI组件库                               |
| Redux Toolkit         | 1.9.5    | 状态管理                               |
| React Router          | 6.14.0   | 路由管理                               |
| ECharts               | 5.4.3    | 复杂图表可视化                         |
| Ant Design Charts     | 2.0.3    | 简单图表可视化                         |
| Axios                 | 1.5.0    | HTTP客户端                             |
| Vite                  | 4.4.0    | 构建工具                               |
| Day.js                | 1.11.9   | 日期时间处理                           |
| Lodash                | 4.17.21  | 实用工具库                             |

#### 3.6.2 组件设计模式

##### 3.6.2.1 组件分类

- **基础UI组件**：封装Ant Design组件，提供统一的样式和行为
- **布局组件**：页面布局、导航菜单、面包屑等
- **图表组件**：基于ECharts和Ant Design Charts封装的图表组件
- **业务组件**：与业务逻辑相关的组件，如规则编辑器、证书上传组件等
- **页面组件**：完整的页面实现

##### 3.6.2.2 组件设计原则

- **单一职责**：每个组件只负责一个功能
- **可复用性**：设计通用组件，提高代码复用率
- **可维护性**：清晰的组件结构和命名
- **可测试性**：组件易于测试
- **性能优化**：合理使用React.memo、useMemo、useCallback等优化组件性能

#### 3.6.3 状态管理实现

##### 3.6.3.1 状态分层

- **全局状态**：系统配置、用户信息、主题设置等
- **页面级状态**：各页面的状态，如表格数据、筛选条件等
- **组件级状态**：组件内部的状态

##### 3.6.3.2 Redux Toolkit配置

```javascript
// src/store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import overviewReducer from './slices/overviewSlice';
import firewallReducer from './slices/firewallSlice';
import prerenderReducer from './slices/prerenderSlice';
import sslReducer from './slices/sslSlice';
import monitoringReducer from './slices/monitoringSlice';
import logsReducer from './slices/logsSlice';
import settingsReducer from './slices/settingsSlice';

export const store = configureStore({
  reducer: {
    overview: overviewReducer,
    firewall: firewallReducer,
    prerender: prerenderReducer,
    ssl: sslReducer,
    monitoring: monitoringReducer,
    logs: logsReducer,
    settings: settingsReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false,
    }),
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

##### 3.6.3.3 示例Slice

```javascript
// src/store/slices/overviewSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { getOverviewData } from '../../services/overview';
import { OverviewData } from '../../types/overview';

export const fetchOverviewData = createAsyncThunk(
  'overview/fetchData',
  async () => {
    const response = await getOverviewData();
    return response.data;
  }
);

interface OverviewState {
  data: OverviewData | null;
  loading: boolean;
  error: string | null;
}

const initialState: OverviewState = {
  data: null,
  loading: false,
  error: null,
};

const overviewSlice = createSlice({
  name: 'overview',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchOverviewData.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchOverviewData.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchOverviewData.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch overview data';
      });
  },
});

export default overviewSlice.reducer;
```

#### 3.6.4 API服务设计

##### 3.6.4.1 API服务封装

```javascript
// src/services/api.ts
import axios from 'axios';

const apiClient = axios.create({
  baseURL: '/api/v1',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 请求拦截器
apiClient.interceptors.request.use(
  (config) => {
    // 添加认证token等
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
apiClient.interceptors.response.use(
  (response) => {
    return response.data;
  },
  (error) => {
    // 统一处理错误
    return Promise.reject(error);
  }
);

export default apiClient;
```

##### 3.6.4.2 示例API服务

```javascript
// src/services/overview.ts
import apiClient from './api';
import { OverviewData } from '../types/overview';

export const getOverviewData = () => {
  return apiClient.get<OverviewData>('/overview');
};

export const getTrafficTrend = (params: {
  startTime: string;
  endTime: string;
  interval: string;
}) => {
  return apiClient.get('/overview/traffic-trend', { params });
};

export const getSecurityEvents = (params: {
  limit: number;
  offset: number;
}) => {
  return apiClient.get('/overview/security-events', { params });
};
```

#### 3.6.5 图表组件实现

##### 3.6.5.1 基础图表组件封装

```javascript
// src/components/charts/BaseChart.tsx
import React, { useEffect, useRef } from 'react';
import * as echarts from 'echarts';

interface BaseChartProps {
  option: echarts.EChartsOption;
  style?: React.CSSProperties;
  onChartReady?: (chart: echarts.ECharts) => void;
}

const BaseChart: React.FC<BaseChartProps> = ({ option, style, onChartReady }) => {
  const chartRef = useRef<HTMLDivElement>(null);
  const chartInstanceRef = useRef<echarts.ECharts | null>(null);

  useEffect(() => {
    if (!chartRef.current) return;

    // 初始化图表
    const chart = echarts.init(chartRef.current);
    chartInstanceRef.current = chart;

    // 设置图表选项
    chart.setOption(option);

    // 注册图表就绪回调
    if (onChartReady) {
      onChartReady(chart);
    }

    // 响应窗口大小变化
    const handleResize = () => {
      chart.resize();
    };
    window.addEventListener('resize', handleResize);

    // 清理函数
    return () => {
      window.removeEventListener('resize', handleResize);
      chart.dispose();
      chartInstanceRef.current = null;
    };
  }, [option, onChartReady]);

  // 更新图表选项
  useEffect(() => {
    if (chartInstanceRef.current) {
      chartInstanceRef.current.setOption(option, true);
    }
  }, [option]);

  return <div ref={chartRef} style={{ width: '100%', height: '100%', ...style }} />;
};

export default BaseChart;
```

##### 3.6.5.2 业务图表组件

```javascript
// src/components/charts/TrafficTrendChart.tsx
import React from 'react';
import BaseChart from './BaseChart';
import { TrafficTrendData } from '../../types/overview';

interface TrafficTrendChartProps {
  data: TrafficTrendData[];
  height?: number;
}

const TrafficTrendChart: React.FC<TrafficTrendChartProps> = ({ data, height = 300 }) => {
  const option = {
    tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'cross',
      },
    },
    legend: {
      data: ['总请求数', '爬虫请求数', '攻击拦截数'],
      bottom: 0,
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '15%',
      top: '3%',
      containLabel: true,
    },
    xAxis: {
      type: 'category',
      boundaryGap: false,
      data: data.map(item => item.time),
      axisLabel: {
        rotate: 45,
      },
    },
    yAxis: {
      type: 'value',
    },
    series: [
      {
        name: '总请求数',
        type: 'line',
        data: data.map(item => item.totalRequests),
        smooth: true,
        lineStyle: {
          color: '#1890ff',
        },
      },
      {
        name: '爬虫请求数',
        type: 'line',
        data: data.map(item => item.crawlerRequests),
        smooth: true,
        lineStyle: {
          color: '#52c41a',
        },
      },
      {
        name: '攻击拦截数',
        type: 'line',
        data: data.map(item => item.blockedRequests),
        smooth: true,
        lineStyle: {
          color: '#f5222d',
        },
      },
    ],
  };

  return <BaseChart option={option} style={{ height }} />;
};

export default TrafficTrendChart;
```

#### 3.6.6 开发流程和规范

##### 3.6.6.1 开发流程

1. **需求分析**：理解功能需求，确定技术实现方案
2. **组件设计**：设计组件结构和API
3. **开发实现**：编写代码，实现功能
4. **测试**：编写单元测试和集成测试
5. **代码评审**：提交代码评审
6. **部署**：构建和部署

##### 3.6.6.2 编码规范

- **命名规范**：
  - 组件名：PascalCase
  - 变量名和函数名：camelCase
  - 常量名：UPPER_CASE_WITH_UNDERSCORES
  - 文件和目录名：kebab-case

- **代码格式**：
  - 使用Prettier自动格式化代码
  - 使用ESLint检查代码质量
  - 每行代码不超过120个字符
  - 适当的缩进和空格

- **注释规范**：
  - 为公共组件和函数添加JSDoc注释
  - 为复杂的业务逻辑添加注释
  - 为关键变量和常量添加注释

#### 3.6.7 构建和部署

##### 3.6.7.1 开发环境

```bash
# 安装依赖
npm install

# 启动开发服务器
npm run dev

# 访问 http://localhost:5173
```

##### 3.6.7.2 构建生产版本

```bash
# 构建生产版本
npm run build

# 预览生产版本
npm run preview
```

##### 3.6.7.3 部署方式

- **Docker部署**：构建Docker镜像，部署到容器环境
- **静态文件部署**：将构建后的静态文件部署到CDN或Web服务器
- **Kubernetes部署**：部署到Kubernetes集群

## 4. 开发流程

### 4.1 分支管理策略

| 分支类型            | 用途                     | 命名规则                |
|---------------------|--------------------------|-------------------------|
| 主分支              | 稳定版本发布             | main                    |
| 开发分支            | 日常开发                 | develop                 |
| 功能分支            | 新功能开发               | feature/xxx             |
| 修复分支            |  bug修复                 | fix/xxx                 |
| 发布分支            | 版本发布准备             | release/vx.y.z          |
| 热修复分支          | 生产环境紧急修复         | hotfix/xxx              |

### 4.2 开发工作流

1. **需求分析**：根据需求文档，明确开发任务和验收标准
2. **任务分解**：将开发任务分解为具体的开发项
3. **分支创建**：从develop分支创建功能分支或修复分支
4. **代码开发**：按照编码规范进行代码开发
5. **单元测试**：编写和运行单元测试
6. **代码评审**：提交代码进行评审
7. **集成测试**：将代码合并到develop分支，进行集成测试
8. **发布准备**：从develop分支创建发布分支，进行发布准备
9. **版本发布**：将发布分支合并到main分支，发布版本
10. **部署上线**：将发布的版本部署到生产环境

### 4.3 编码规范

#### 4.3.1 Go编码规范

- 遵循Go官方编码规范（gofmt）
- 使用golint进行代码检查
- 函数和变量命名清晰，遵循驼峰命名法
- 代码注释完整，包括函数功能、参数和返回值
- 错误处理完整，避免忽略错误

#### 4.3.2 JavaScript/TypeScript编码规范

- 遵循Airbnb编码规范
- 使用ESLint进行代码检查
- 使用Prettier进行代码格式化
- 函数和变量命名清晰，遵循驼峰命名法
- 代码注释完整，包括函数功能、参数和返回值

### 4.4 CI/CD流程

#### 4.4.1 持续集成

1. **代码提交**：开发人员将代码提交到Git仓库
2. **自动构建**：触发CI流水线，进行代码构建
3. **单元测试**：运行单元测试，检查代码质量
4. **集成测试**：运行集成测试，检查模块间集成情况
5. **代码质量检查**：使用SonarQube进行代码质量分析
6. **安全扫描**：使用Trivy进行容器和代码漏洞扫描
7. **镜像构建**：构建Docker镜像，推送到镜像仓库

#### 4.4.2 持续部署

1. **环境准备**：准备部署环境，包括服务器、网络等
2. **配置更新**：更新部署配置，包括版本号、资源配置等
3. **镜像拉取**：从镜像仓库拉取最新镜像
4. **服务部署**：部署服务，包括容器创建、网络配置等
5. **健康检查**：检查服务健康状态，确保服务正常运行
6. **滚动更新**：采用滚动更新策略，确保服务不中断
7. **回滚机制**：支持一键回滚，确保部署失败时可以快速恢复

## 5. 测试策略

### 5.1 测试类型

#### 5.1.1 单元测试

- **测试目标**：测试单个函数或模块的功能
- **测试工具**：GoTest（Go）、Jest（JavaScript/TypeScript）
- **测试覆盖率**：要求核心模块覆盖率达到80%以上

#### 5.1.2 集成测试

- **测试目标**：测试模块间的集成和协作
- **测试工具**：GoTest + httptest（Go）、Supertest（JavaScript/TypeScript）
- **测试场景**：模拟真实业务场景，测试模块间的交互

#### 5.1.3 端到端测试

- **测试目标**：测试整个系统的功能和性能
- **测试工具**：Playwright、Cypress
- **测试场景**：模拟真实用户行为，测试系统的完整流程

#### 5.1.4 性能测试

- **测试目标**：测试系统的性能和可靠性
- **测试工具**：Gatling、JMeter
- **测试指标**：QPS、响应时间、错误率、并发数

#### 5.1.5 安全测试

- **测试目标**：测试系统的安全性
- **测试工具**：OWASP ZAP、Nessus
- **测试内容**：漏洞扫描、渗透测试、安全配置检查

### 5.2 测试流程

1. **测试计划**：根据需求文档，制定测试计划和测试用例
2. **测试执行**：按照测试计划，执行各种类型的测试
3. **缺陷管理**：记录和跟踪测试中发现的缺陷
4. **缺陷修复**：开发人员修复缺陷，提交代码
5. **回归测试**：重新执行测试，确保缺陷已修复
6. **测试报告**：生成测试报告，包括测试结果和覆盖率

## 6. 部署方式

### 6.1 单节点部署

#### 6.1.1 Docker Compose部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  gateway:
    image: prerender-firewall/gateway:latest
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./configs:/etc/prerender-firewall
      - ./certs:/etc/prerender-firewall/certs
    environment:
      - SSL_ENABLED=true
      - SSL_CERT_PATH=/etc/prerender-firewall/certs/cert.pem
      - SSL_KEY_PATH=/etc/prerender-firewall/certs/key.pem
      - SSL_LETS_ENCRYPT=false
    depends_on:
      - etcd
      - redis
      - postgres

  api:
    image: prerender-firewall/api:latest
    ports:
      - "8080:8080"
    volumes:
      - ./configs:/etc/prerender-firewall
    depends_on:
      - etcd
      - redis
      - postgres

  firewall:
    image: prerender-firewall/firewall:latest
    volumes:
      - ./configs:/etc/prerender-firewall
    depends_on:
      - etcd
      - redis
      - postgres

  prerender:
    image: prerender-firewall/prerender:latest
    volumes:
      - ./configs:/etc/prerender-firewall
    depends_on:
      - etcd
      - redis

  etcd:
    image: bitnami/etcd:3.5.9
    environment:
      - ALLOW_NONE_AUTHENTICATION=yes
    volumes:
      - etcd_data:/bitnami/etcd

  redis:
    image: bitnami/redis:7.0.12
    environment:
      - ALLOW_EMPTY_PASSWORD=yes
    volumes:
      - redis_data:/bitnami/redis/data

  postgres:
    image: bitnami/postgresql:15.3
    environment:
      - POSTGRESQL_USERNAME=prerender
      - POSTGRESQL_PASSWORD=prerender
      - POSTGRESQL_DATABASE=prerender
    volumes:
      - postgres_data:/bitnami/postgresql

  prometheus:
    image: prom/prometheus:v2.45.0
    ports:
      - "9090:9090"
    volumes:
      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus

  grafana:
    image: grafana/grafana:9.5.0
    ports:
      - "3000:3000"
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  etcd_data:
  redis_data:
  postgres_data:
  prometheus_data:
  grafana_data:
```

#### 6.1.2 部署步骤

```bash
# 1. 准备配置文件
cp configs/example/* configs/
# 2. 修改配置文件，根据实际情况调整
# 3. 启动服务
docker-compose up -d
# 4. 检查服务状态
docker-compose ps
# 5. 访问管理界面 http://localhost:3000
```

### 6.2 集群部署

#### 6.2.1 Kubernetes部署

```yaml
# k8s/deployment.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prerender-firewall-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: prerender-firewall-gateway
  template:
    metadata:
      labels:
        app: prerender-firewall-gateway
    spec:
      containers:
      - name: gateway
        image: prerender-firewall/gateway:latest
        ports:
        - containerPort: 80
        - containerPort: 443
        volumeMounts:
        - name: config
          mountPath: /etc/prerender-firewall
        - name: ssl-certs
          mountPath: /etc/prerender-firewall/certs
        env:
        - name: SSL_ENABLED
          value: "true"
        - name: SSL_CERT_PATH
          value: "/etc/prerender-firewall/certs/tls.crt"
        - name: SSL_KEY_PATH
          value: "/etc/prerender-firewall/certs/tls.key"
        - name: SSL_LETS_ENCRYPT
          value: "false"
      volumes:
      - name: config
        configMap:
          name: prerender-firewall-config
      - name: ssl-certs
        secret:
          secretName: prerender-firewall-tls
```

#### 6.2.2 部署步骤

```bash
# 1. 准备配置文件
kubectl apply -f k8s/configmap.yml
# 2. 部署服务
kubectl apply -f k8s/deployment.yml
kubectl apply -f k8s/service.yml
kubectl apply -f k8s/ingress.yml
# 3. 检查服务状态
kubectl get pods
kubectl get services
kubectl get ingress
# 4. 访问管理界面
```

### 6.3 云原生部署

#### 6.3.1 云平台集成

- **云负载均衡器**：使用云平台提供的负载均衡器，如AWS ALB、阿里云SLB
- **云存储服务**：使用云平台提供的存储服务，如AWS S3、阿里云OSS
- **云监控服务**：集成云平台提供的监控服务，如AWS CloudWatch、阿里云ARMS
- **云日志服务**：集成云平台提供的日志服务，如AWS CloudTrail、阿里云SLS

#### 6.3.2 自动伸缩配置

```yaml
# k8s/hpa.yml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: prerender-firewall-gateway
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: prerender-firewall-gateway
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

## 7. 维护和升级

### 7.1 日常维护

#### 7.1.1 监控和告警

- 定期检查系统监控指标，确保系统正常运行
- 及时处理告警信息，解决系统问题
- 定期备份系统配置和日志数据

#### 7.1.2 日志管理

- 定期清理日志数据，避免磁盘空间不足
- 分析日志数据，发现系统问题和优化点
- 配置日志轮转策略，确保日志数据的完整性

### 7.2 系统升级

#### 7.2.1 升级策略

- **滚动升级**：采用滚动升级策略，确保服务不中断
- **灰度发布**：先将新版本部署到部分节点，验证通过后再全部部署
- **蓝绿部署**：同时运行两个版本的服务，切换流量到新版本

#### 7.2.2 升级步骤

1. **升级准备**：准备升级包和升级文档
2. **备份数据**：备份系统配置和数据
3. **升级测试**：在测试环境进行升级测试
4. **灰度发布**：在生产环境进行灰度发布
5. **全面升级**：将所有节点升级到新版本
6. **验证升级**：验证系统功能和性能
7. **回滚准备**：准备回滚方案，确保升级失败时可以快速恢复

### 7.3 故障处理

#### 7.3.1 常见故障

| 故障类型            | 可能原因                | 解决方案                |
|---------------------|-------------------------|-------------------------|
| 服务不可用          | 进程崩溃、端口占用、资源不足 | 重启服务、释放端口、增加资源 |
| 响应时间过长        | 系统负载高、缓存失效、网络问题 | 增加节点、优化缓存、检查网络 |
| 渲染失败            | Chrome实例崩溃、页面超时、资源加载失败 | 重启渲染服务、调整超时时间、优化页面 |
| 配置失效            | 配置中心问题、配置文件错误 | 检查配置中心、验证配置文件 |

#### 7.3.2 故障处理流程

1. **故障检测**：通过监控和告警，发现系统故障
2. **故障定位**：分析日志和监控数据，定位故障原因
3. **故障修复**：根据故障原因，采取相应的修复措施
4. **故障验证**：验证故障是否已修复
5. **故障复盘**：分析故障原因，总结经验教训，优化系统

## 8. API文档

### 8.1 API版本控制

API采用版本控制，版本号包含在URL中，例如：

```
/api/v1/firewall/rules
```

### 8.2 API认证

API支持两种认证方式：

1. **API Key认证**：在请求头中添加`X-API-Key`字段
2. **JWT认证**：在请求头中添加`Authorization: Bearer <token>`字段

### 8.3 API格式

#### 8.3.1 请求格式

- HTTP方法：GET、POST、PUT、DELETE
- 请求头：Content-Type: application/json
- 请求体：JSON格式

#### 8.3.2 响应格式

```json
{
  "code": 200,
  "message": "success",
  "data": {}
}
```

### 8.4 核心API示例

#### 8.4.1 防火墙规则API

```
# 获取防火墙规则
GET /api/v1/firewall/rules

# 创建防火墙规则
POST /api/v1/firewall/rules
{
  "name": "SQL注入防护",
  "type": "sql_injection",
  "action": "block",
  "priority": 100,
  "enabled": true
}

# 更新防火墙规则
PUT /api/v1/firewall/rules/{id}
{
  "enabled": false
}

# 删除防火墙规则
DELETE /api/v1/firewall/rules/{id}
```

#### 8.4.2 渲染预热规则API

```
# 获取渲染预热规则
GET /api/v1/prerender/rules

# 创建渲染预热规则
POST /api/v1/prerender/rules
{
  "name": "首页渲染预热",
  "url_pattern": "^/$",
  "enabled": true,
  "cache_ttl": 3600
}

# 手动触发渲染预热
POST /api/v1/prerender/trigger
{
  "url": "https://example.com"
}
```

#### 8.4.3 缓存预热API

```
# 获取预热任务列表
GET /api/v1/prerender/preheat/tasks

# 触发一键预热
POST /api/v1/prerender/preheat/trigger

# 获取预热状态
GET /api/v1/prerender/preheat/status
```

#### 8.4.4 SSL证书API

```
# 获取SSL配置
GET /api/v1/ssl/config

# 更新SSL配置
PUT /api/v1/ssl/config
{
  "enabled": true,
  "lets_encrypt": false,
  "cert_path": "/etc/certs/cert.pem",
  "key_path": "/etc/certs/key.pem",
  "tls_protocols": ["TLSv1.2", "TLSv1.3"],
  "hsts": true,
  "hsts_max_age": 31536000
}

# 上传SSL证书
POST /api/v1/ssl/cert/upload
Content-Type: multipart/form-data

# 申请Let's Encrypt证书
POST /api/v1/ssl/cert/letsencrypt
{
  "domains": ["example.com"],
  "email": "admin@example.com",
  "challenge_type": "http-01"
}

# 获取证书列表
GET /api/v1/ssl/certs

# 获取证书详情
GET /api/v1/ssl/certs/{id}

# 删除证书
DELETE /api/v1/ssl/certs/{id}
```

## 9. 开发规范和最佳实践

### 9.1 代码质量

- 遵循编码规范，使用代码检查工具
- 编写单元测试，提高代码覆盖率
- 进行代码评审，确保代码质量
- 使用静态代码分析工具，发现潜在问题

### 9.2 性能优化

- 使用高效的算法和数据结构
- 实现缓存机制，减少重复计算
- 优化数据库查询，使用索引
- 采用异步处理，提高系统吞吐量

### 9.3 安全最佳实践

- 遵循最小权限原则
- 对敏感数据进行加密存储和传输
- 实现严格的认证和授权机制
- 定期进行安全审计和漏洞扫描
- 及时更新依赖组件和补丁

### 9.4 可维护性

- 编写清晰、简洁的代码
- 提供完整的代码注释
- 遵循模块化设计原则
- 实现良好的错误处理机制
- 提供详细的日志记录

## 10. 项目管理

### 10.1 开发进度管理

- 使用敏捷开发方法，进行迭代开发
- 每个迭代周期为2周
- 每周进行一次迭代评审和回顾
- 使用项目管理工具，如Jira、Trello，跟踪开发进度

### 10.2 文档管理

- 维护完整的项目文档，包括需求文档、功能文档、架构设计文档、开发文档
- 文档更新及时，与代码保持同步
- 使用版本控制工具管理文档
- 提供在线文档，便于查阅

### 10.3 团队协作

- 建立清晰的沟通机制，如每日站会、周会
- 共享知识和经验，提高团队整体能力
- 建立代码评审机制，确保代码质量
- 保持良好的团队氛围，鼓励协作和创新

## 11. 结论

本开发文档详细描述了渲染预热防火墙产品的开发环境搭建、项目结构、核心模块技术实现、开发流程、测试策略、部署方式、维护和升级等内容。通过遵循本文档的指导，可以确保产品的开发质量和进度，提高产品的可维护性和扩展性，为用户提供高质量的产品和服务。